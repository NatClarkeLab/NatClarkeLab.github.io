[{"name": "app.py", "content": "# app.py \u2014 CODA v5 (Shinylive version, optimize-only)\n#\n# Assumptions:\n# - A prebuilt codon usage table for Clytia hemisphaerica\n#   with columns: AA, Codon, Freq\n#\n# Features:\n# - paste or small FASTA input (multi-FASTA allowed)\n# - weighted vs max codon selection\n# - global GC% target + tolerance (with resampling)\n# - local GC smoothing (sliding window)\n# - restriction-site avoidance (common + user-defined)\n#\nfrom shiny import App, ui, render, reactive\nimport pandas as pd\nfrom io import StringIO\nimport math, random\nfrom collections import defaultdict\n\n# --------------------------------------------------------------------\n# 1) Load prebuilt Clytia codon table\n# --------------------------------------------------------------------\n\n# Hard-coded Clytia codon usage table (from your TSV)\n_CLYTIA_TSV = \"\"\"AA\\tCodon\\tFreq\nA\\tGCA\\t0.333074\nA\\tGCC\\t0.172147\nA\\tGCG\\t0.111050\nA\\tGCT\\t0.383729\nC\\tTGC\\t0.330857\nC\\tTGT\\t0.669143\nD\\tGAC\\t0.339494\nD\\tGAT\\t0.660506\nE\\tGAA\\t0.715725\nE\\tGAG\\t0.284275\nF\\tTTC\\t0.480780\nF\\tTTT\\t0.519220\nG\\tGGA\\t0.370537\nG\\tGGC\\t0.154563\nG\\tGGG\\t0.106658\nG\\tGGT\\t0.368241\nH\\tCAC\\t0.383527\nH\\tCAT\\t0.616473\nI\\tATA\\t0.197013\nI\\tATC\\t0.381572\nI\\tATT\\t0.421415\nK\\tAAA\\t0.699703\nK\\tAAG\\t0.300297\nL\\tCTA\\t0.094536\nL\\tCTC\\t0.103374\nL\\tCTG\\t0.109787\nL\\tCTT\\t0.182453\nL\\tTTA\\t0.228060\nL\\tTTG\\t0.281790\nM\\tATG\\t1.000000\nN\\tAAC\\t0.428620\nN\\tAAT\\t0.571380\nP\\tCCA\\t0.434930\nP\\tCCC\\t0.124583\nP\\tCCG\\t0.145795\nP\\tCCT\\t0.294692\nQ\\tCAA\\t0.765589\nQ\\tCAG\\t0.234411\nR\\tAGA\\t0.298971\nR\\tAGG\\t0.105937\nR\\tCGA\\t0.216399\nR\\tCGC\\t0.095310\nR\\tCGG\\t0.066438\nR\\tCGT\\t0.216944\nS\\tAGC\\t0.109563\nS\\tAGT\\t0.192324\nS\\tTCA\\t0.277630\nS\\tTCC\\t0.115688\nS\\tTCG\\t0.110129\nS\\tTCT\\t0.194666\nT\\tACA\\t0.372847\nT\\tACC\\t0.191318\nT\\tACG\\t0.155054\nT\\tACT\\t0.280781\nV\\tGTA\\t0.173085\nV\\tGTC\\t0.250308\nV\\tGTG\\t0.202228\nV\\tGTT\\t0.374379\nW\\tTGG\\t1.000000\nY\\tTAC\\t0.444234\nY\\tTAT\\t0.555766\n\"\"\"\n\ndef load_clytia_table_from_string():\n    df = pd.read_csv(StringIO(_CLYTIA_TSV), sep=\"\\t\")\n    table = {}\n    for aa, sub in df.groupby(\"AA\"):\n        table[aa] = {row[\"Codon\"]: float(row[\"Freq\"]) for _, row in sub.iterrows()}\n    return table\n\ncodon_table = load_clytia_table_from_string()\n\n# CAI weights: w_aa,codon = freq / max_freq_for_that_aa\ndef build_cai_weights(table):\n    weights = {}\n    for aa, codons in table.items():\n        max_f = max(codons.values()) if codons else 1.0\n        weights[aa] = {cod: (f / max_f if max_f > 0 else 0.0) for cod, f in codons.items()}\n    return weights\n\nCAI_WEIGHTS = build_cai_weights(codon_table)\n\n# --------------------------------------------------------------------\n# 2) Core genetic code + helpers (from CODA v5 logic)\n# --------------------------------------------------------------------\nSTOP = {\"TAA\", \"TAG\", \"TGA\"}\nCODON2AA = {\n    \"TTT\":\"F\",\"TTC\":\"F\",\"TTA\":\"L\",\"TTG\":\"L\",\n    \"TCT\":\"S\",\"TCC\":\"S\",\"TCA\":\"S\",\"TCG\":\"S\",\n    \"TAT\":\"Y\",\"TAC\":\"Y\",\"TAA\":\"*\",\"TAG\":\"*\",\n    \"TGT\":\"C\",\"TGC\":\"C\",\"TGA\":\"*\",\"TGG\":\"W\",\n    \"CTT\":\"L\",\"CTC\":\"L\",\"CTA\":\"L\",\"CTG\":\"L\",\n    \"CCT\":\"P\",\"CCC\":\"P\",\"CCA\":\"P\",\"CCG\":\"P\",\n    \"CAT\":\"H\",\"CAC\":\"H\",\"CAA\":\"Q\",\"CAG\":\"Q\",\n    \"CGT\":\"R\",\"CGC\":\"R\",\"CGA\":\"R\",\"CGG\":\"R\",\n    \"ATT\":\"I\",\"ATC\":\"I\",\"ATA\":\"I\",\"ATG\":\"M\",\n    \"ACT\":\"T\",\"ACC\":\"T\",\"ACA\":\"T\",\"ACG\":\"T\",\n    \"AAT\":\"N\",\"AAC\":\"N\",\"AAA\":\"K\",\"AAG\":\"K\",\n    \"AGT\":\"S\",\"AGC\":\"S\",\"AGA\":\"R\",\"AGG\":\"R\",\n    \"GTT\":\"V\",\"GTC\":\"V\",\"GTA\":\"V\",\"GTG\":\"V\",\n    \"GCT\":\"A\",\"GCC\":\"A\",\"GCA\":\"A\",\"GCG\":\"A\",\n    \"GAT\":\"D\",\"GAC\":\"D\",\"GAA\":\"E\",\"GAG\":\"E\",\n    \"GGT\":\"G\",\"GGC\":\"G\",\"GGA\":\"G\",\"GGG\":\"G\",\n}\nfrom collections import defaultdict\nAA2CODONS = defaultdict(list)\nfor c,a in CODON2AA.items():\n    if a != \"*\":\n        AA2CODONS[a].append(c)\n\nDEFAULT_SITES = [\n    \"GAATTC\",\"GGATCC\",\"AAGCTT\",\"CTCGAG\",\"GCGGCCGC\",\"GCTAGC\",\"TCTAGA\",\"ACTAGT\",\n    \"CTGCAG\",\"GGTACC\",\"GAGCTC\",\"AGATCT\",\"GTCGAC\",\"GCATGC\",\"ACCGGT\"\n]\n\ndef parse_fasta_string(s: str):\n    s = s.strip()\n    if not s:\n        return []\n    if not s.startswith(\">\"):\n        return [(\"seq\", \"\".join(s.split()).upper())]\n    recs = []\n    header = None\n    seq = []\n    for line in s.splitlines():\n        line = line.strip()\n        if not line:\n            continue\n        if line.startswith(\">\"):\n            if header is not None:\n                recs.append((header, \"\".join(seq).upper()))\n            header = line[1:].strip()\n            seq = []\n        else:\n            seq.append(line)\n    if header is not None:\n        recs.append((header, \"\".join(seq).upper()))\n    return recs\n\ndef translate(dna: str):\n    dna = dna.upper().replace(\"U\", \"T\")\n    pep = []\n    for i in range(0, len(dna) - 2, 3):\n        cod = dna[i:i+3]\n        aa = CODON2AA.get(cod, \"X\")\n        if aa == \"*\":\n            break\n        pep.append(aa)\n    return \"\".join(pep)\n\ndef compute_gc(seq: str) -> float:\n    s = seq.upper()\n    a = s.count(\"A\"); c = s.count(\"C\"); g = s.count(\"G\"); t = s.count(\"T\")\n    den = a + c + g + t\n    return 100.0 * (g + c) / den if den else 0.0\n\ndef compute_gc3(seq: str) -> float:\n    s = seq.upper()\n    L = (len(s)//3)*3\n    if L == 0: return 0.0\n    third = s[2:L:3]\n    den = len(third)\n    if den == 0: return 0.0\n    gc = third.count(\"G\") + third.count(\"C\")\n    return 100.0 * gc / den\n\ndef _gc_fraction(seq: str) -> float:\n    if not seq: return 0.0\n    s = seq.upper()\n    den = s.count(\"A\") + s.count(\"C\") + s.count(\"G\") + s.count(\"T\")\n    return (s.count(\"G\") + s.count(\"C\")) / den if den else 0.0\n\ndef _contains_site_tail(seq_tail: str, sites) -> bool:\n    s = seq_tail.upper()\n    return any(site in s for site in sites)\n\ndef _local_gc_adjust(codons, probs, built_seq, window, target_gc, tol, strength=4.0, sites=None):\n    # Local GC steering + restriction site penalty\n    if window <= 0 or target_gc is None or tol is None:\n        return list(probs)\n    tail = built_seq[-max(0, window-3):] if built_seq else \"\"\n    adj = []\n    max_site_len = max((len(x) for x in sites), default=0) if sites else 0\n    for c, p in zip(codons, probs):\n        w = p\n        new = tail + c\n        gc_new = _gc_fraction(new)\n        excess = max(0.0, abs(gc_new - target_gc) - tol)\n        if excess > 0:\n            w *= math.exp(-strength * excess)\n        if sites:\n            check_tail = (built_seq + c)[-(max_site_len + 8):]\n            if _contains_site_tail(check_tail, sites):\n                w *= 1e-6\n        adj.append(w)\n    s = sum(adj)\n    if s == 0:\n        return list(probs)\n    return [x/s for x in adj]\n\ndef optimize_from_table(prot: str, table, strategy=\"weighted\", rng=None,\n                        local_gc_opts=None, avoid_sites=None) -> str:\n    rng = rng or random.Random(12345)\n    out = []\n    built = \"\"\n    for aa in prot:\n        if aa == \"*\":\n            break\n        d = table.get(aa, {})\n        if not d:\n            # fallback to any codon for this AA\n            choices = AA2CODONS.get(aa, [])\n            if choices:\n                pick = choices[0]\n                out.append(pick); built += pick\n            continue\n        codons, probs = zip(*d.items())\n        if local_gc_opts:\n            probs = _local_gc_adjust(\n                codons, probs, built_seq=built,\n                window=local_gc_opts.get(\"window\", 60),\n                target_gc=local_gc_opts.get(\"target_gc\"),\n                tol=local_gc_opts.get(\"tol\", 0.05),\n                strength=local_gc_opts.get(\"strength\", 4.0),\n                sites=avoid_sites\n            )\n        if strategy == \"max\":\n            idx = max(range(len(codons)), key=lambda i: probs[i])\n            pick = codons[idx]\n        else:\n            r = rng.random() * sum(probs)\n            acc = 0.0\n            pick = codons[-1]\n            for c, p in zip(codons, probs):\n                acc += p\n                if r <= acc:\n                    pick = c\n                    break\n        out.append(pick)\n        built += pick\n    return \"\".join(out)\n\ndef optimize_with_gc(prot: str, table, strategy=\"weighted\",\n                     target_gc=None, tol=None, tries=400,\n                     local_gc_opts=None, avoid_sites=None) -> str:\n    def within(gc):\n        if target_gc is None or tol is None: return True\n        return (target_gc - tol) <= gc <= (target_gc + tol)\n\n    best = optimize_from_table(prot, table, strategy=strategy,\n                               local_gc_opts=local_gc_opts,\n                               avoid_sites=avoid_sites)\n    best_gc = compute_gc(best)\n    if within(best_gc):\n        return best\n\n    # resample to get closer\n    best_seq, best_diff = best, abs(best_gc - (target_gc if target_gc is not None else best_gc))\n    for seed in range(1000, 1000 + tries):\n        rng = random.Random(seed)\n        cand = optimize_from_table(prot, table, strategy=\"weighted\", rng=rng,\n                                   local_gc_opts=local_gc_opts,\n                                   avoid_sites=avoid_sites)\n        gc = compute_gc(cand)\n        if within(gc):\n            return cand\n        diff = abs(gc - (target_gc if target_gc is not None else gc))\n        if diff < best_diff:\n            best_seq, best_diff = cand, diff\n    return best_seq\n\ndef cai(seq: str, weights: dict) -> float:\n    vals = []\n    seq = seq.upper()\n    for i in range(0, len(seq) - 2, 3):\n        cod = seq[i:i+3]\n        aa = CODON2AA.get(cod)\n        if not aa or aa == \"*\":\n            break\n        w = weights.get(aa, {}).get(cod, 1e-6)  # small floor\n        vals.append(w)\n    if not vals:\n        return 0.0\n    # geometric mean\n    s = 0.0\n    for v in vals:\n        s += math.log(v)\n    return math.exp(s / len(vals))\n\n\n# --------------------------------------------------------------------\n# 3) Shiny UI\n# --------------------------------------------------------------------\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_text_area(\"seq\", \"Paste DNA or FASTA\", rows=10),\n        ui.input_radio_buttons(\n            \"strategy\",\n            \"Codon selection\",\n            choices={\"weighted\": \"Weighted (host-like)\", \"max\": \"Most frequent\"},\n            selected=\"weighted\",\n        ),\n        ui.hr(),\n        ui.input_checkbox(\"enforce_gc\", \"Enforce global GC% bounds\", value=True),\n        ui.input_numeric(\"target_gc\", \"Target GC%\", 40.0),\n        ui.input_numeric(\"gc_tol\", \"Tolerance (\u00b1 %GC)\", 5.0),\n        ui.hr(),\n        ui.input_checkbox(\"use_local\", \"Enable local GC smoothing\", value=True),\n        ui.input_numeric(\"window\", \"Window (nt)\", 60),\n        ui.input_numeric(\"local_tol\", \"Local tol (\u00b1 %GC)\", 5.0),\n        ui.input_numeric(\"strength\", \"Bias strength\", 4.0),\n        ui.hr(),\n        ui.input_checkbox(\"avoid_sites\", \"Avoid common restriction sites\", value=False),\n        ui.input_text(\"custom_sites\", \"Custom sites (comma-separated)\", \"\"),\n        ui.hr(),\n        ui.input_action_button(\"run\", \"Optimize\"),\n    ),\n    ui.layout_columns(  # main content\n        ui.card(\n            ui.card_header(\"Optimized FASTA\"),\n            ui.output_text_verbatim(\"fasta_out\"),\n        ),\n        ui.card(\n            ui.card_header(\"Metrics\"),\n            ui.output_table(\"metrics\"),\n        ),\n    ),\n    title=\"Clytia Codon Optimizer\",\n)\n\n\n# --------------------------------------------------------------------\n# 4) Server\n# --------------------------------------------------------------------\ndef server(input, output, session):\n\n    @reactive.Calc\n    def sequences():\n        return parse_fasta_string(input.seq() or \"\")\n\n    @output\n    @render.text\n    @reactive.event(input.run)\n    def fasta_out():\n        recs = sequences()\n        if not recs:\n            return \"No sequence provided.\"\n        # prepare options\n        enforce = input.enforce_gc()\n        target_gc = input.target_gc()\n        gc_tol = input.gc_tol()\n        use_local = input.use_local()\n        loc_opts = None\n        if use_local:\n            loc_opts = {\n                \"window\": int(input.window()),\n                \"target_gc\": target_gc / 100.0,\n                \"tol\": input.local_tol() / 100.0,\n                \"strength\": float(input.strength()),\n            }\n        sites = None\n        if input.avoid_sites():\n            sites = list(DEFAULT_SITES)\n            extra = (input.custom_sites() or \"\").strip()\n            if extra:\n                sites += [x.strip().upper() for x in extra.split(\",\") if x.strip()]\n\n        out_lines = []\n        for hdr, dna in recs:\n            prot = translate(dna)\n            seq_opt = optimize_with_gc(\n                prot,\n                codon_table,\n                strategy=input.strategy(),\n                target_gc=(target_gc if enforce else None),\n                tol=(gc_tol if enforce else None),\n                tries=400,\n                local_gc_opts=loc_opts,\n                avoid_sites=sites,\n            )\n            wrapped = \"\\n\".join(seq_opt[i:i+70] for i in range(0, len(seq_opt), 70))\n            out_lines.append(f\">optimized|{hdr}\\n{wrapped}\")\n        return \"\\n\".join(out_lines)\n\n    @output\n    @render.table\n    @reactive.event(input.run)\n    def metrics():\n        recs = sequences()\n        rows = []\n        enforce = input.enforce_gc()\n        target_gc = input.target_gc()\n        gc_tol = input.gc_tol()\n        use_local = input.use_local()\n        loc_opts = None\n        if use_local:\n            loc_opts = {\n                \"window\": int(input.window()),\n                \"target_gc\": target_gc / 100.0,\n                \"tol\": input.local_tol() / 100.0,\n                \"strength\": float(input.strength()),\n            }\n        sites = None\n        if input.avoid_sites():\n            sites = list(DEFAULT_SITES)\n            extra = (input.custom_sites() or \"\").strip()\n            if extra:\n                sites += [x.strip().upper() for x in extra.split(\",\") if x.strip()]\n        for hdr, dna in recs:\n            prot = translate(dna)\n            seq_opt = optimize_with_gc(\n                prot,\n                codon_table,\n                strategy=input.strategy(),\n                target_gc=(target_gc if enforce else None),\n                tol=(gc_tol if enforce else None),\n                tries=400,\n                local_gc_opts=loc_opts,\n                avoid_sites=sites,\n            )\n            seq_in = \"\".join(dna.upper().split())\n            rows.append({\n                \"name\": hdr,\n                \"len_nt\": len(seq_opt),\n                \"GC%\": compute_gc(seq_opt),\n                \"GC3%\": compute_gc3(seq_opt),\n                \"CAI (input)\": cai(seq_in, CAI_WEIGHTS),\n                \"CAI (optimized)\": cai(seq_opt, CAI_WEIGHTS),\n                \"delta CAI\": cai(seq_opt, CAI_WEIGHTS) - cai(seq_in, CAI_WEIGHTS),\n            })\n\n        return pd.DataFrame(rows)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "clytia_codon_usage.tsv", "content": "AA\tCodon\tFreq\nA\tGCA\t0.333074\nA\tGCC\t0.172147\nA\tGCG\t0.111050\nA\tGCT\t0.383729\nC\tTGC\t0.330857\nC\tTGT\t0.669143\nD\tGAC\t0.339494\nD\tGAT\t0.660506\nE\tGAA\t0.715725\nE\tGAG\t0.284275\nF\tTTC\t0.480780\nF\tTTT\t0.519220\nG\tGGA\t0.370537\nG\tGGC\t0.154563\nG\tGGG\t0.106658\nG\tGGT\t0.368241\nH\tCAC\t0.383527\nH\tCAT\t0.616473\nI\tATA\t0.197013\nI\tATC\t0.381572\nI\tATT\t0.421415\nK\tAAA\t0.699703\nK\tAAG\t0.300297\nL\tCTA\t0.094536\nL\tCTC\t0.103374\nL\tCTG\t0.109787\nL\tCTT\t0.182453\nL\tTTA\t0.228060\nL\tTTG\t0.281790\nM\tATG\t1.000000\nN\tAAC\t0.428620\nN\tAAT\t0.571380\nP\tCCA\t0.434930\nP\tCCC\t0.124583\nP\tCCG\t0.145795\nP\tCCT\t0.294692\nQ\tCAA\t0.765589\nQ\tCAG\t0.234411\nR\tAGA\t0.298971\nR\tAGG\t0.105937\nR\tCGA\t0.216399\nR\tCGC\t0.095310\nR\tCGG\t0.066438\nR\tCGT\t0.216944\nS\tAGC\t0.109563\nS\tAGT\t0.192324\nS\tTCA\t0.277630\nS\tTCC\t0.115688\nS\tTCG\t0.110129\nS\tTCT\t0.194666\nT\tACA\t0.372847\nT\tACC\t0.191318\nT\tACG\t0.155054\nT\tACT\t0.280781\nV\tGTA\t0.173085\nV\tGTC\t0.250308\nV\tGTG\t0.202228\nV\tGTT\t0.374379\nW\tTGG\t1.000000\nY\tTAC\t0.444234\nY\tTAT\t0.555766\n", "type": "text"}, {"name": "www/clytia_codon_usage.tsv", "content": "AA\tCodon\tFreq\nA\tGCA\t0.333074\nA\tGCC\t0.172147\nA\tGCG\t0.111050\nA\tGCT\t0.383729\nC\tTGC\t0.330857\nC\tTGT\t0.669143\nD\tGAC\t0.339494\nD\tGAT\t0.660506\nE\tGAA\t0.715725\nE\tGAG\t0.284275\nF\tTTC\t0.480780\nF\tTTT\t0.519220\nG\tGGA\t0.370537\nG\tGGC\t0.154563\nG\tGGG\t0.106658\nG\tGGT\t0.368241\nH\tCAC\t0.383527\nH\tCAT\t0.616473\nI\tATA\t0.197013\nI\tATC\t0.381572\nI\tATT\t0.421415\nK\tAAA\t0.699703\nK\tAAG\t0.300297\nL\tCTA\t0.094536\nL\tCTC\t0.103374\nL\tCTG\t0.109787\nL\tCTT\t0.182453\nL\tTTA\t0.228060\nL\tTTG\t0.281790\nM\tATG\t1.000000\nN\tAAC\t0.428620\nN\tAAT\t0.571380\nP\tCCA\t0.434930\nP\tCCC\t0.124583\nP\tCCG\t0.145795\nP\tCCT\t0.294692\nQ\tCAA\t0.765589\nQ\tCAG\t0.234411\nR\tAGA\t0.298971\nR\tAGG\t0.105937\nR\tCGA\t0.216399\nR\tCGC\t0.095310\nR\tCGG\t0.066438\nR\tCGT\t0.216944\nS\tAGC\t0.109563\nS\tAGT\t0.192324\nS\tTCA\t0.277630\nS\tTCC\t0.115688\nS\tTCG\t0.110129\nS\tTCT\t0.194666\nT\tACA\t0.372847\nT\tACC\t0.191318\nT\tACG\t0.155054\nT\tACT\t0.280781\nV\tGTA\t0.173085\nV\tGTC\t0.250308\nV\tGTG\t0.202228\nV\tGTT\t0.374379\nW\tTGG\t1.000000\nY\tTAC\t0.444234\nY\tTAT\t0.555766\n", "type": "text"}]